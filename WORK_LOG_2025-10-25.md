# 백엔드 작업 로그 - 2025년 10월 25일

## 작업 개요
User Service에 JWT 토큰 발급 기능 및 사용자 프로필 관련 엔드포인트 추가

---

## 1. 문제: 회원가입 시 JWT 토큰 미발급

### 문제 상황
- User Service에서 회원가입 시 `ApiResponse<UserResponse>` 형식으로만 응답
- JWT 토큰이 발급되지 않아 프론트엔드에서 임시 토큰 사용
- 실제 인증/인가 기능 부재

### 해결 과정

#### 1.1 JWT 유틸리티 클래스 생성
**파일:** `backend/user-service/src/main/java/com/example/userservice/util/JwtUtil.java`

```java
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration:86400000}") // 24시간
    private Long expiration;
    
    @Value("${jwt.refresh-expiration:604800000}") // 7일
    private Long refreshExpiration;
    
    // Access Token 생성
    public String generateAccessToken(String email, Long userId, String role)
    
    // Refresh Token 생성
    public String generateRefreshToken(String email)
    
    // 토큰 검증 및 정보 추출
    public String extractEmail(String token)
    public Long extractUserId(String token)
    public Boolean validateToken(String token, String email)
}
```

**주요 기능:**
- HS256 알고리즘 사용
- Access Token: 24시간 유효
- Refresh Token: 7일 유효
- 사용자 이메일, ID, 역할 정보 포함

#### 1.2 AuthResponse DTO 생성
**파일:** `backend/user-service/src/main/java/com/example/userservice/dto/AuthResponse.java`

```java
public class AuthResponse {
    private String accessToken;
    private String refreshToken;
    private UserResponse user;
}
```

#### 1.3 회원가입 엔드포인트 수정
**파일:** `backend/user-service/src/main/java/com/example/userservice/controller/UserController.java`

**변경 전:**
```java
@PostMapping("/register")
public ResponseEntity<ApiResponse<UserResponse>> registerUser(@Valid @RequestBody UserRegistrationRequest request) {
    UserResponse userResponse = userService.registerUser(request);
    ApiResponse<UserResponse> response = ApiResponse.success("회원가입이 성공적으로 완료되었습니다.", userResponse);
    return ResponseEntity.status(HttpStatus.CREATED).body(response);
}
```

**변경 후:**
```java
@PostMapping("/register")
public ResponseEntity<ApiResponse<AuthResponse>> registerUser(@Valid @RequestBody UserRegistrationRequest request) {
    UserResponse userResponse = userService.registerUser(request);
    
    // JWT 토큰 생성
    String accessToken = jwtUtil.generateAccessToken(
        userResponse.getEmail(), 
        userResponse.getId(), 
        userResponse.getRole().name()
    );
    String refreshToken = jwtUtil.generateRefreshToken(userResponse.getEmail());
    
    AuthResponse authResponse = new AuthResponse(accessToken, refreshToken, userResponse);
    ApiResponse<AuthResponse> response = ApiResponse.success("회원가입이 성공적으로 완료되었습니다.", authResponse);
    return ResponseEntity.status(HttpStatus.CREATED).body(response);
}
```

#### 1.4 JWT 설정 추가
**파일:** `backend/user-service/src/main/resources/application.yml`

```yaml
# JWT 설정
jwt:
  secret: ${JWT_SECRET:maltan-secret-key-for-jwt-token-generation-minimum-256-bits-required}
  expiration: ${JWT_EXPIRATION:86400000} # 24시간 (밀리초)
  refresh-expiration: ${JWT_REFRESH_EXPIRATION:604800000} # 7일 (밀리초)
```

---

## 2. 문제: 사용자 프로필 관련 엔드포인트 부재

### 문제 상황
- 프론트엔드에서 `/api/user/me` 호출 시 404 에러
- `/api/user/me/preferred-regions` 엔드포인트 없음
- 사용자 프로필 업데이트, 비밀번호 변경 기능 없음

### 해결 과정

#### 2.1 필요한 DTO 생성

**파일:** `backend/user-service/src/main/java/com/example/userservice/dto/UpdateProfileRequest.java`
```java
public class UpdateProfileRequest {
    private String name;
    private String phoneNumber;
    @Valid
    private List<PreferredRegionDto> preferredRegions;
}
```

**파일:** `backend/user-service/src/main/java/com/example/userservice/dto/ChangePasswordRequest.java`
```java
public class ChangePasswordRequest {
    @NotBlank(message = "현재 비밀번호는 필수입니다")
    private String currentPassword;
    
    @NotBlank(message = "새 비밀번호는 필수입니다")
    @Size(min = 6, message = "비밀번호는 최소 6자 이상이어야 합니다")
    private String newPassword;
}
```

**파일:** `backend/user-service/src/main/java/com/example/userservice/dto/PreferredRegionsResponse.java`
```java
public class PreferredRegionsResponse {
    private List<PreferredRegionDto> preferredRegions;
}
```

#### 2.2 UserService에 메서드 추가
**파일:** `backend/user-service/src/main/java/com/example/userservice/service/UserService.java`

```java
// 현재 사용자의 선호 지역 조회
public PreferredRegionsResponse getMyPreferredRegions(String email) {
    User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + email));
    UserResponse userResponse = new UserResponse(user);
    return new PreferredRegionsResponse(userResponse.getPreferredRegions());
}

// 현재 사용자 프로필 업데이트
public UserResponse updateMyProfile(String email, UpdateProfileRequest request) {
    User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + email));
    
    if (request.getName() != null && !request.getName().trim().isEmpty()) {
        user.setName(request.getName());
    }
    if (request.getPhoneNumber() != null) {
        user.setPhoneNumber(request.getPhoneNumber());
    }
    if (request.getPreferredRegions() != null && !request.getPreferredRegions().isEmpty()) {
        String preferredRegionsJson = convertPreferredRegionsToJson(request.getPreferredRegions());
        user.setPreferredRegionsJson(preferredRegionsJson);
    }
    
    User updatedUser = userRepository.save(user);
    return new UserResponse(updatedUser);
}

// 현재 사용자 비밀번호 변경
public void changeMyPassword(String email, ChangePasswordRequest request) {
    User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + email));
    
    if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPassword())) {
        throw new RuntimeException("현재 비밀번호가 일치하지 않습니다");
    }
    
    user.setPassword(passwordEncoder.encode(request.getNewPassword()));
    userRepository.save(user);
}
```

#### 2.3 UserController에 엔드포인트 추가
**파일:** `backend/user-service/src/main/java/com/example/userservice/controller/UserController.java`

```java
// 현재 사용자 정보 조회
@GetMapping("/me")
public ResponseEntity<ApiResponse<UserResponse>> getMyInfo(@RequestParam String email) {
    Optional<UserResponse> user = userService.findByEmail(email);
    if (user.isPresent()) {
        ApiResponse<UserResponse> response = ApiResponse.success(user.get());
        return ResponseEntity.ok(response);
    } else {
        ApiResponse<UserResponse> response = ApiResponse.error("사용자를 찾을 수 없습니다", 404);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
}

// 현재 사용자의 선호 지역 조회
@GetMapping("/me/preferred-regions")
public ResponseEntity<PreferredRegionsResponse> getMyPreferredRegions(@RequestParam String email) {
    PreferredRegionsResponse response = userService.getMyPreferredRegions(email);
    return ResponseEntity.ok(response);
}

// 현재 사용자 프로필 업데이트
@PutMapping("/me")
public ResponseEntity<ApiResponse<UserResponse>> updateMyProfile(
        @RequestParam String email,
        @Valid @RequestBody UpdateProfileRequest request) {
    UserResponse userResponse = userService.updateMyProfile(email, request);
    ApiResponse<UserResponse> response = ApiResponse.success("프로필이 성공적으로 업데이트되었습니다.", userResponse);
    return ResponseEntity.ok(response);
}

// 현재 사용자 비밀번호 변경
@PutMapping("/me/password")
public ResponseEntity<ApiResponse<String>> changeMyPassword(
        @RequestParam String email,
        @Valid @RequestBody ChangePasswordRequest request) {
    userService.changeMyPassword(email, request);
    ApiResponse<String> response = ApiResponse.success("비밀번호가 성공적으로 변경되었습니다.", "변경 완료");
    return ResponseEntity.ok(response);
}
```

#### 2.4 Spring Security 설정 업데이트
**파일:** `backend/user-service/src/main/java/com/example/userservice/config/SecurityConfig.java`

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .csrf(csrf -> csrf.disable())
        .authorizeHttpRequests(authz -> authz
            .requestMatchers("OPTIONS", "/**").permitAll()
            .requestMatchers("/user/auth/register", "/user/auth/health").permitAll()
            .requestMatchers("/user/auth/check-username/**", "/user/auth/check-email/**").permitAll()
            .requestMatchers("/user/auth/username/**", "/user/auth/email/**").permitAll()
            .requestMatchers("/user/auth/{id}").permitAll()
            .requestMatchers("/user/auth/me/**").permitAll() // 추가
            .requestMatchers("/user/auth/me").permitAll() // 추가
            .requestMatchers("/test/**").permitAll()
            .anyRequest().authenticated()
        )
        .httpBasic(httpBasic -> httpBasic.disable());
    
    return http.build();
}
```

---

## 3. 문제: 회원가입 시 필드 검증 오류

### 문제 상황
- 프론트엔드에서 `name` 필드를 보내지만 백엔드는 `username` 필드 기대
- `phone` 필드가 필수로 설정되어 있어 선택사항으로 변경 필요

### 해결 과정

#### 3.1 UserRegistrationRequest 수정
**파일:** `backend/user-service/src/main/java/com/example/userservice/dto/UserRegistrationRequest.java`

**변경 전:**
```java
@NotBlank(message = "사용자명은 필수입니다")
private String username;

@NotBlank(message = "전화번호는 필수입니다")
private String phone;
```

**변경 후:**
```java
@NotBlank(message = "이름은 필수입니다")
private String name;

private String username; // 선택사항 (없으면 email 사용)

private String phone; // 선택사항
```

#### 3.2 UserService 로직 수정
**파일:** `backend/user-service/src/main/java/com/example/userservice/service/UserService.java`

```java
public UserResponse registerUser(UserRegistrationRequest request) {
    // username이 없으면 email을 사용
    String username = request.getUsername();
    if (username == null || username.trim().isEmpty()) {
        username = request.getEmail();
    }
    
    // 새 사용자 생성
    User user = new User();
    user.setUsername(username);
    user.setEmail(request.getEmail());
    user.setPassword(passwordEncoder.encode(request.getPassword()));
    user.setName(request.getName()); // 실제 이름 사용
    user.setPhoneNumber(request.getPhone());
    // ...
}
```

#### 3.3 User Entity 수정
**파일:** `backend/user-service/src/main/java/com/example/userservice/entity/User.java`

```java
// @NotBlank 제거
@Size(min = 3, max = 50, message = "사용자명은 3-50자 사이여야 합니다")
@Column(unique = true, nullable = false)
private String username; // email을 기본값으로 사용
```

---

## 4. 배포 관련 설정

### 4.1 Docker 컨테이너 자동 재시작 설정
**파일:** `.github/workflows/deploy-user.yml`

```yaml
- name: Run New Container
  run: |
    docker run -d \
      --name user-service \
      --network maltan-network \
      --restart unless-stopped \  # 추가
      -p 8081:8081 \
      -e DB_HOST=10.0.2.15 \
      -e DB_PORT=3306 \
      -e DB_NAME=user_service \
      -e DB_USERNAME=root \
      -e DB_PASSWORD=password \
      -e SERVER_PORT=8081 \
      user-service:latest
```

**적용된 모든 서비스:**
- user-service
- community-service
- place-service
- gateway-service
- recommendation-service

---

## 최종 API 엔드포인트 목록

### 인증 관련
- `POST /api/user/auth/register` - 회원가입 (JWT 토큰 발급)
- `GET /api/user/auth/health` - 헬스 체크

### 사용자 조회
- `GET /api/user/auth/{id}` - ID로 사용자 조회
- `GET /api/user/auth/username/{username}` - 사용자명으로 조회
- `GET /api/user/auth/email/{email}` - 이메일로 조회

### 중복 검사
- `GET /api/user/auth/check-username/{username}` - 사용자명 중복 검사
- `GET /api/user/auth/check-email/{email}` - 이메일 중복 검사

### 현재 사용자 관련 (신규 추가)
- `GET /api/user/auth/me?email={email}` - 현재 사용자 정보 조회
- `GET /api/user/auth/me/preferred-regions?email={email}` - 선호 지역 조회
- `PUT /api/user/auth/me?email={email}` - 프로필 업데이트
- `PUT /api/user/auth/me/password?email={email}` - 비밀번호 변경

---

## 의존성

### pom.xml
```xml
<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
</dependency>
```

---

## 주요 개선 사항

1. **보안 강화**
   - JWT 토큰 기반 인증 구현
   - Access Token (24시간) + Refresh Token (7일)
   - HS256 알고리즘 사용

2. **API 완성도 향상**
   - 사용자 프로필 관련 CRUD 엔드포인트 추가
   - 선호 지역 조회 기능 추가
   - 비밀번호 변경 기능 추가

3. **유연성 개선**
   - `username` 필드를 선택사항으로 변경 (email 자동 사용)
   - `phone` 필드를 선택사항으로 변경
   - 실제 이름(`name`)과 사용자명(`username`) 분리

4. **운영 안정성**
   - Docker 컨테이너 자동 재시작 설정
   - 재부팅 후에도 서비스 자동 복구

---

## 테스트 방법

### 1. 회원가입 테스트
```bash
curl -X POST http://localhost:8081/api/user/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "name": "홍길동",
    "preferredRegions": [
      {
        "city": "11",
        "cityName": "서울특별시",
        "district": "11680",
        "districtName": "강남구",
        "priority": 1
      }
    ]
  }'
```

**예상 응답:**
```json
{
  "success": true,
  "message": "회원가입이 성공적으로 완료되었습니다.",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiJ9...",
    "user": {
      "id": 1,
      "email": "test@example.com",
      "name": "홍길동",
      "username": "test@example.com",
      "role": "USER"
    }
  }
}
```

### 2. 사용자 정보 조회
```bash
curl -X GET "http://localhost:8081/api/user/auth/me?email=test@example.com"
```

### 3. 선호 지역 조회
```bash
curl -X GET "http://localhost:8081/api/user/auth/me/preferred-regions?email=test@example.com"
```

---

## 다음 단계 (TODO)

1. **로그인 엔드포인트 구현**
   - `POST /api/user/auth/login`
   - 이메일/비밀번호 검증 후 JWT 토큰 발급

2. **토큰 갱신 엔드포인트 구현**
   - `POST /api/user/auth/refresh`
   - Refresh Token으로 새로운 Access Token 발급

3. **JWT 인증 필터 구현**
   - Spring Security Filter Chain에 JWT 검증 추가
   - 보호된 엔드포인트에 대한 인증 강제

4. **프로필 이미지 업로드 구현**
   - `POST /api/user/auth/me/profile-image`
   - 파일 업로드 및 저장 로직

5. **비밀번호 찾기/재설정 기능**
   - 이메일 인증을 통한 비밀번호 재설정

