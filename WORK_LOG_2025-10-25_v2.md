# 작업 일지 - 2025년 10월 25일 (v3)

## 📋 작업 개요
1. 커뮤니티 서비스의 인증 시스템 임시 구현 및 인기 게시글 기능 추가
2. 관리자 페이지 실시간 모니터링 구현
3. User Service와 Community Service 간 연동 (사용자 이름 조회)
4. 게시글/댓글 작성 후 응답 처리 수정

---

## 🔧 User Service

### 1. 관리자 페이지 실시간 시스템 모니터링 API 추가

#### 신규 파일

**1) SystemMetrics.java (DTO)**
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SystemMetrics {
    private Double cpuUsage;      // CPU 사용률 (%)
    private Double memoryUsage;   // 메모리 사용률 (%)
    private Double diskUsage;     // 디스크 사용률 (%)
    private Long totalMemory;     // 전체 메모리 (bytes)
    private Long usedMemory;      // 사용 중인 메모리 (bytes)
    private Long freeMemory;      // 여유 메모리 (bytes)
}
```

**2) SystemMetricsService.java**
```java
@Service
public class SystemMetricsService {
    
    public SystemMetrics getSystemMetrics() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        Runtime runtime = Runtime.getRuntime();
        
        // CPU 사용률
        double cpuUsage = osBean.getSystemLoadAverage() / osBean.getAvailableProcessors() * 100;
        
        // 메모리 정보
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        double memoryUsage = (double) usedMemory / totalMemory * 100;
        
        // 디스크 사용률
        File root = new File("/");
        long totalSpace = root.getTotalSpace();
        long freeSpace = root.getFreeSpace();
        double diskUsage = (double) (totalSpace - freeSpace) / totalSpace * 100;
        
        return SystemMetrics.builder()
            .cpuUsage(Math.max(0, Math.min(100, cpuUsage)))
            .memoryUsage(memoryUsage)
            .diskUsage(diskUsage)
            .totalMemory(totalMemory)
            .usedMemory(usedMemory)
            .freeMemory(freeMemory)
            .build();
    }
}
```

**3) AdminUserController.java - 엔드포인트 추가**
```java
@GetMapping("/system/metrics")
public ResponseEntity<SystemMetrics> getSystemMetrics() {
    SystemMetrics metrics = systemMetricsService.getSystemMetrics();
    return ResponseEntity.ok(metrics);
}
```

---

### 2. Internal API 추가 (다른 서비스에서 사용자 이름 조회)

#### 신규 파일

**InternalUserController.java**
```java
@RestController
@RequestMapping("/user/internal")  // context-path가 /api이므로 실제 경로는 /api/user/internal
@RequiredArgsConstructor
public class InternalUserController {
    
    private final UserRepository userRepository;
    
    /**
     * 사용자 ID로 이름 조회
     */
    @GetMapping("/users/{userId}/name")
    public ResponseEntity<Map<String, String>> getUserName(@PathVariable Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + userId));
        
        Map<String, String> response = new HashMap<>();
        response.put("userId", String.valueOf(userId));
        response.put("name", user.getName());
        
        return ResponseEntity.ok(response);
    }
}
```

#### 주의사항
- User Service의 `context-path`가 `/api`로 설정되어 있음
- `@RequestMapping("/user/internal")`로 설정하면 실제 경로는 `/api/user/internal`이 됨
- Community Service에서 호출 시 `http://10.0.2.15:8081/api/user/internal/users/{userId}/name` 사용

---

## 💬 Community Service

### 1. 임시 인증 시스템 구현 (userId 전달)

#### 문제점
- 프론트엔드에서 API 호출 시 `@RequestAttribute("userId")`가 없어 500 에러 발생
- 게이트웨이/인증 필터가 완전히 구현되지 않아 userId가 전달되지 않음

#### 해결 방법
모든 컨트롤러에서 `@RequestAttribute`를 선택사항으로 변경하고, 임시로 요청 본문/쿼리 파라미터에서 userId를 받도록 수정

#### 수정된 파일

**1) CreatePostRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**2) PostController.java**
```java
@PostMapping
public ResponseEntity<PostResponse> createPost(
        @Valid @RequestBody CreatePostRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    // 임시: 인증 시스템 구현 전까지 요청 본문에서 userId 사용
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    PostDto post = postService.createPost(request, userId);
    return ResponseEntity.status(HttpStatus.CREATED)
        .body(PostResponse.builder().post(post).build());
}
```

**3) CreateCommentRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**4) CommentController.java**
```java
@PostMapping("/posts/{postId}/comments")
public ResponseEntity<CommentDto> createComment(
        @PathVariable Long postId,
        @Valid @RequestBody CreateCommentRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    CommentDto comment = commentService.createComment(postId, request, userId);
    return ResponseEntity.status(HttpStatus.CREATED).body(comment);
}
```

**5) VoteRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**6) VoteController.java**
```java
// 게시글 투표
@PostMapping("/posts/{postId}/vote")
public ResponseEntity<VoteResponse> votePost(
        @PathVariable Long postId,
        @Valid @RequestBody VoteRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    VoteResponse response = voteService.votePost(postId, request, userId);
    return ResponseEntity.ok(response);
}

// 게시글 투표 취소
@DeleteMapping("/posts/{postId}/vote")
public ResponseEntity<VoteResponse> cancelPostVote(
        @PathVariable Long postId,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute,
        @RequestParam(required = false) Long userId
) {
    Long finalUserId = userIdFromAttribute != null ? userIdFromAttribute : userId;
    if (finalUserId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    VoteResponse response = voteService.cancelPostVote(postId, finalUserId);
    return ResponseEntity.ok(response);
}

// 댓글 투표도 동일한 패턴으로 수정
```

**7) RecruitmentController.java**
```java
@PostMapping("/{postId}/participate")
public ResponseEntity<ParticipateResponse> toggleParticipation(
        @PathVariable Long postId,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute,
        @RequestParam(required = false) Long userId
) {
    Long finalUserId = userIdFromAttribute != null ? userIdFromAttribute : userId;
    if (finalUserId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    ParticipateResponse response = recruitmentService.toggleParticipation(postId, finalUserId);
    return ResponseEntity.ok(response);
}
```

---

### 2. 인기 게시글 기능 추가

#### 기능 설명
- 매일 자정에 지난 24시간 동안 가장 많은 추천을 받은 게시글을 선정
- 선정된 게시글은 24시간 동안 목록 최상단에 고정
- 최소 10개 이상의 추천을 받아야 인기 게시글로 선정

#### 수정/추가된 파일

**1) Post.java (엔티티)**
```java
// 인기 게시글 (상단 고정)
@Column(name = "is_pinned")
@Builder.Default
private Boolean isPinned = false;

@Column(name = "pinned_until")
private LocalDateTime pinnedUntil;

// 비즈니스 메서드
public void pin(LocalDateTime until) {
    this.isPinned = true;
    this.pinnedUntil = until;
}

public void unpin() {
    this.isPinned = false;
    this.pinnedUntil = null;
}

public boolean isPinnedAndValid() {
    return this.isPinned && 
           this.pinnedUntil != null && 
           LocalDateTime.now().isBefore(this.pinnedUntil);
}
```

**2) PostDto.java**
```java
// 인기 게시글
private Boolean isPinned;
private LocalDateTime pinnedUntil;
```

**3) PostService.java**
```java
// convertToDto 메서드에 추가
.isPinned(post.getIsPinned())
.pinnedUntil(post.getPinnedUntil())
```

**4) PostRepository.java**
```java
// 특정 기간 이후 가장 많은 추천을 받은 게시글 조회
@Query("SELECT p FROM Post p WHERE p.isDeleted = false " +
       "AND p.createdAt >= :since " +
       "ORDER BY p.likeCount DESC, p.viewCount DESC")
List<Post> findTopByLikeCountSince(@Param("since") LocalDateTime since, int limit);

// 고정 기간이 만료된 게시글 조회
List<Post> findByIsPinnedTrueAndPinnedUntilBefore(LocalDateTime now);

// 복합 검색 쿼리 수정 - 인기 게시글 우선 정렬
@Query("SELECT p FROM Post p WHERE p.isDeleted = false " +
       "AND (:category IS NULL OR p.category = :category) " +
       "AND (:regionSi IS NULL OR p.regionSi = :regionSi) " +
       "AND (:regionGu IS NULL OR p.regionGu = :regionGu) " +
       "AND (:regionDong IS NULL OR p.regionDong = :regionDong) " +
       "AND (:isRecruitment IS NULL OR p.isRecruitment = :isRecruitment) " +
       "ORDER BY " +
       "CASE WHEN p.isPinned = true AND p.pinnedUntil > CURRENT_TIMESTAMP THEN 0 ELSE 1 END, " +
       "p.createdAt DESC")
Page<Post> findByFilters(...);
```

**5) PopularPostScheduler.java (신규 파일)**
```java
@Component
public class PopularPostScheduler {
    
    /**
     * 매일 자정에 인기 게시글 선정 및 고정
     */
    @Scheduled(cron = "0 0 0 * * *")
    @Transactional
    public void updatePopularPost() {
        // 기존 고정 게시글 해제
        unpinExpiredPosts();
        
        // 지난 24시간 동안 가장 많은 추천을 받은 게시글 찾기
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        List<Post> topPosts = postRepository.findTopByLikeCountSince(yesterday, 1);
        
        if (!topPosts.isEmpty()) {
            Post topPost = topPosts.get(0);
            
            // 최소 추천 수 조건 (10개 이상)
            if (topPost.getLikeCount() >= 10) {
                // 24시간 동안 고정
                LocalDateTime pinnedUntil = LocalDateTime.now().plusDays(1);
                topPost.pin(pinnedUntil);
                postRepository.save(topPost);
                
                log.info("인기 게시글 선정 완료: postId={}, likeCount={}", 
                    topPost.getId(), topPost.getLikeCount());
            }
        }
    }
    
    /**
     * 매 시간마다 만료된 고정 게시글 해제
     */
    @Scheduled(cron = "0 0 * * * *")
    @Transactional
    public void unpinExpiredPosts() {
        LocalDateTime now = LocalDateTime.now();
        List<Post> expiredPosts = postRepository.findByIsPinnedTrueAndPinnedUntilBefore(now);
        
        for (Post post : expiredPosts) {
            post.unpin();
            postRepository.save(post);
            log.info("고정 해제: postId={}", post.getId());
        }
    }
}
```

---

### 3. User Service 연동 (사용자 이름 조회)

#### 문제점
- 기존에는 게시글/댓글에 사용자 이름을 저장하지 않아 "사용자1", "사용자2" 등으로 표시됨
- DB에 중복 데이터를 저장하는 것보다 User Service를 참조하는 것이 데이터 일관성 유지에 유리

#### 해결 방법
Community Service에서 게시글/댓글 조회 시 User Service API를 호출하여 실시간으로 사용자 이름을 가져옴

#### 신규 파일

**1) UserServiceClient.java**
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class UserServiceClient {
    
    private final RestTemplate restTemplate;
    
    @Value("${user.service.url:http://localhost:8081}")
    private String userServiceUrl;
    
    /**
     * User Service에서 사용자 이름 조회
     */
    public String getUserName(Long userId) {
        try {
            String url = userServiceUrl + "/api/user/internal/users/" + userId + "/name";
            Map<String, Object> response = restTemplate.getForObject(url, Map.class);
            
            if (response != null && response.containsKey("name")) {
                return (String) response.get("name");
            }
            
            log.warn("User Service에서 사용자 이름을 찾을 수 없음: userId={}", userId);
            return "사용자" + userId;
        } catch (Exception e) {
            log.error("User Service 호출 실패: userId={}", userId, e);
            return "사용자" + userId;
        }
    }
}
```

**2) RestTemplateConfig.java**
```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### 수정된 파일

**1) PostService.java**
```java
@RequiredArgsConstructor
public class PostService {
    // ...
    private final UserServiceClient userServiceClient;
    
    private PostDto convertToDto(Post post, Long currentUserId) {
        // ...
        
        // User Service에서 사용자 이름 조회 (기존 임시값 제거)
        String userName = userServiceClient.getUserName(post.getUserId());
        
        return PostDto.builder()
            .userId(post.getUserId())
            .userName(userName)  // 실제 사용자 이름
            // ...
            .build();
    }
}
```

**2) CommentService.java**
```java
@RequiredArgsConstructor
public class CommentService {
    // ...
    private final UserServiceClient userServiceClient;
    
    private CommentDto convertToDto(Comment comment, Long currentUserId) {
        // ...
        
        // User Service에서 사용자 이름 조회
        String userName = userServiceClient.getUserName(comment.getUserId());
        
        return CommentDto.builder()
            .userId(comment.getUserId())
            .userName(userName)  // 실제 사용자 이름
            .userNickname(userName)  // 호환성을 위해 동일한 값 설정
            // ...
            .build();
    }
}
```

**3) application.yml**
```yaml
# User Service Configuration
user:
  service:
    url: ${USER_SERVICE_URL:http://localhost:8081}
```

**4) deploy-community.yml (GitHub Actions)**
```yaml
- name: Run New Container
  run: |
    docker run -d \
      --name community-service \
      # ... 기존 환경 변수들
      -e USER_SERVICE_URL=http://10.0.2.15:8081 \
      community-service:latest
```

#### 장점
- ✅ DB에 중복 데이터 저장 안 함
- ✅ User Service에서 이름이 변경되면 자동으로 반영
- ✅ 마이크로서비스 간 데이터 일관성 유지

---

## 🎨 Frontend

### 1. 커뮤니티 API 호출 시 userId 전달

#### 수정된 파일

**1) communityService.ts**
```typescript
// CreatePostRequest 인터페이스
export interface CreatePostRequest {
  // ... 기존 필드들
  userId?: number;  // 임시: 인증 시스템 구현 전까지 필요
}

// CreateCommentRequest 인터페이스
export interface CreateCommentRequest {
  content: string;
  parentCommentId?: number;
  userId?: number;  // 임시: 인증 시스템 구현 전까지 필요
}

// 투표 함수들
export const votePost = async (postId: number, voteType: 'LIKE' | 'DISLIKE', userId?: number): Promise<void> => {
  await api.post(`/api/community/posts/${postId}/vote`, { voteType, userId });
};

export const unvotePost = async (postId: number, userId?: number): Promise<void> => {
  await api.delete(`/api/community/posts/${postId}/vote${userId ? `?userId=${userId}` : ''}`);
};

export const voteComment = async (commentId: number, voteType: 'LIKE' | 'DISLIKE', userId?: number): Promise<void> => {
  await api.post(`/api/community/comments/${commentId}/vote`, { voteType, userId });
};

export const unvoteComment = async (commentId: number, userId?: number): Promise<void> => {
  await api.delete(`/api/community/comments/${commentId}/vote${userId ? `?userId=${userId}` : ''}`);
};

// 모집 참여
export const toggleParticipation = async (postId: number, userId?: number): Promise<{ participated: boolean; currentCount: number }> => {
  const response = await api.post(`/api/community/posts/${postId}/participate${userId ? `?userId=${userId}` : ''}`);
  return response.data;
};

// Post 인터페이스에 인기 게시글 필드 추가
export interface Post {
  // ... 기존 필드들
  isPinned?: boolean;  // 인기 게시글 여부
  pinnedUntil?: string;  // 고정 만료 시간
}
```

**2) CommunityWritePage.tsx**
```typescript
import { useAppSelector } from '../store/hooks';

const CommunityWritePage: React.FC = () => {
  const { user } = useAppSelector((state) => state.auth);
  
  const handleSubmit = async () => {
    // ... 기존 코드
    
    // userId 추가 (임시: 인증 시스템 구현 전까지)
    if (user?.id) {
      request.userId = parseInt(user.id);
    }
    
    const post = await createPost(request);
    navigate(`/community/${post.id}`);
  };
};
```

**3) CommunityDetailPage.tsx**
```typescript
// 투표 처리
const handleVote = async (voteType: 'LIKE' | 'DISLIKE') => {
  if (!id || !user?.id) return;
  const userId = parseInt(user.id);
  
  try {
    if (myVote === voteType) {
      await unvotePost(parseInt(id), userId);
    } else {
      await votePost(parseInt(id), voteType, userId);
    }
    // ... 상태 업데이트
  } catch (err: any) {
    alert(err.response?.data?.message || '추천/비추천에 실패했습니다.');
  }
};

// 모집 참여 처리
const handleParticipate = async () => {
  if (!id || !user?.id) return;
  const userId = parseInt(user.id);
  
  try {
    const result = await toggleParticipation(parseInt(id), userId);
    setParticipated(result.participated);
    // ... 상태 업데이트
  } catch (err: any) {
    alert(err.response?.data?.message || '참여 처리에 실패했습니다.');
  }
};

// 댓글 작성 처리
const handleSubmitComment = async () => {
  await createComment(parseInt(id), {
    content: newComment,
    parentCommentId: replyTo || undefined,
    userId: user?.id ? parseInt(user.id) : undefined,
  });
};
```

---

### 2. 인기 게시글 시각적 표시

**CommunityPage.tsx**
```typescript
import { Whatshot } from '@mui/icons-material';

// 게시글 카드에 인기 아이콘 추가
<Box sx={{ display: 'flex', gap: 1, mb: 1, flexWrap: 'wrap', alignItems: 'center' }}>
  {post.isPinned && post.pinnedUntil && new Date(post.pinnedUntil) > new Date() && (
    <Chip
      label="인기"
      size="small"
      color="error"
      icon={<Whatshot />}
      sx={{
        fontWeight: 'bold',
        animation: 'pulse 2s ease-in-out infinite',
        '@keyframes pulse': {
          '0%, 100%': { opacity: 1 },
          '50%': { opacity: 0.7 },
        },
      }}
    />
  )}
  {/* 기존 카테고리, 지역 등의 칩들 */}
</Box>
```

---

### 3. 지도 디버깅 로그 추가

**HomePage.tsx**
```typescript
// 선호 지역 데이터 로딩 시 로그
const fetchPreferredRegions = async () => {
  const data = await getMyPreferredRegions();
  console.log('선호 지역 데이터:', data);
  console.log('1순위 지역:', firstRegion);
  console.log('1순위 지역 좌표:', coordinate);
};

// 지도에서 보기 버튼 클릭 시 로그
<Button onClick={() => {
  console.log('지도에서 보기 클릭:', region);
  const coordinate = getCoordinatesByDistrict(region.district);
  console.log('찾은 좌표:', coordinate);
  if (coordinate) {
    console.log('지도 중심 변경:', coordinate.latitude, coordinate.longitude);
    setMapCenter({ latitude: coordinate.latitude, longitude: coordinate.longitude });
  } else {
    console.error('좌표를 찾을 수 없습니다. district:', region.district);
  }
}}>
  지도에서 보기
</Button>
```

---

### 4. 관리자 페이지 실시간 모니터링

#### 수정된 파일

**1) adminService.ts**
```typescript
// 시스템 메트릭 인터페이스
export interface SystemMetrics {
  cpuUsage: number;
  memoryUsage: number;
  diskUsage: number;
  totalMemory: number;
  usedMemory: number;
  freeMemory: number;
}

// 시스템 메트릭 조회
export const getSystemMetrics = async (): Promise<SystemMetrics> => {
  const response = await api.get('/user/admin/system/metrics');
  return response.data;
};
```

**2) DashboardPage.tsx**
```typescript
// 실시간 애니메이션 상태
const [animatedCpu, setAnimatedCpu] = useState(0);
const [animatedMemory, setAnimatedMemory] = useState(0);
const [animatedDisk, setAnimatedDisk] = useState(0);

// 5초마다 자동 새로고침
useEffect(() => {
  const interval = setInterval(() => {
    fetchStats();
  }, 5000);
  return () => clearInterval(interval);
}, []);

// 애니메이션 효과
useEffect(() => {
  if (!metrics) return;
  
  const animateValue = (start: number, end: number, setter: (v: number) => void) => {
    const duration = 1000;
    const steps = 60;
    const increment = (end - start) / steps;
    let current = start;
    let step = 0;
    
    const timer = setInterval(() => {
      step++;
      current += increment;
      if (step >= steps) {
        setter(end);
        clearInterval(timer);
      } else {
        setter(current);
      }
    }, duration / steps);
  };
  
  animateValue(animatedCpu, metrics.cpuUsage, setAnimatedCpu);
  animateValue(animatedMemory, metrics.memoryUsage, setAnimatedMemory);
  animateValue(animatedDisk, metrics.diskUsage, setAnimatedDisk);
}, [metrics]);

// 리소스 사용률 카드에 펄스 애니메이션 추가
<Box sx={{
  animation: 'pulse 2s ease-in-out infinite',
  '@keyframes pulse': {
    '0%, 100%': { opacity: 1 },
    '50%': { opacity: 0.8 },
  },
}}>
  <LinearProgress 
    variant="determinate" 
    value={animatedCpu}
    sx={{
      transition: 'all 0.3s ease-in-out',
    }}
  />
</Box>
```

---

### 5. 게시글/댓글 작성 후 응답 처리 수정

#### 문제점
- 백엔드가 `{post: {...}}` 형태로 응답을 반환
- 프론트엔드에서 `response.data`를 직접 사용하여 `post.id`가 `undefined`가 됨
- 결과적으로 `/api/community/posts/NaN`으로 리다이렉트되어 500 에러 발생

#### 해결 방법

**communityService.ts**
```typescript
// 게시글 작성
export const createPost = async (data: CreatePostRequest): Promise<Post> => {
  const response = await api.post('/api/community/posts', data);
  // Backend에서 {post: {...}} 형태로 반환하므로 post 추출
  return response.data.post || response.data;
};

// 게시글 수정
export const updatePost = async (postId: number, data: Partial<CreatePostRequest>): Promise<Post> => {
  const response = await api.put(`/api/community/posts/${postId}`, data);
  // Backend에서 {post: {...}} 형태로 반환하므로 post 추출
  return response.data.post || response.data;
};
```

---

### 6. 사용자 이름 표시 개선

#### 수정된 파일

**1) Layout.tsx**
```typescript
// 헤더에서 사용자 이름 표시
<Typography variant="body2" sx={{ mr: 1 }}>
  {user?.name || user?.username}님
</Typography>
```

**2) ProfilePage.tsx**
```typescript
// 프로필 페이지에서 이름 표시
<Typography variant="h6" gutterBottom>
  {profile?.name || profile?.username}
</Typography>
```

**3) CommunityPage.tsx**
```typescript
// 게시글 작성자 표시
<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
  <Avatar sx={{ width: 24, height: 24 }}>
    {post.userName ? post.userName.charAt(0) : 'U'}
  </Avatar>
  <Typography variant="caption" color="text.secondary">
    {post.userName || `사용자${post.userId}`}
  </Typography>
</Box>
```

**4) CommunityDetailPage.tsx**
```typescript
// 게시글 상세 페이지에서 작성자 표시
<Avatar sx={{ width: 32, height: 32 }}>
  {post.userName ? post.userName[0] : 'U'}
</Avatar>
<Typography variant="body2" color="text.secondary">
  {post.userName || `사용자${post.userId}`}
</Typography>

// 댓글 작성자 표시
<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
  <Avatar sx={{ width: 24, height: 24 }}>
    {comment.userName ? comment.userName.charAt(0) : 'U'}
  </Avatar>
  <Typography variant="body2" fontWeight="bold">
    {comment.userName || `사용자${comment.userId}`}
  </Typography>
</Box>
```

**5) communityService.ts - Comment 인터페이스**
```typescript
export interface Comment {
  id: number;
  postId: number;
  userId: number;
  userName?: string;  // 추가
  parentCommentId?: number;
  content: string;
  likeCount: number;
  dislikeCount: number;
  isDeleted: boolean;
  createdAt: string;
  updatedAt: string;
  replies?: Comment[];
}
```

---

## 📊 배포 현황

### 백엔드 커밋 (최신순)
1. `fix: correct InternalUserController path to work with context-path`
   - InternalUserController의 경로를 `/user/internal`로 수정
   - context-path `/api`와 결합하여 실제 경로 `/api/user/internal` 생성
   
2. `fix: fetch user names from User Service for posts`
   - PostService에서 User Service API를 호출하여 사용자 이름 조회
   
3. `feat: integrate User Service for fetching user names in Community Service`
   - UserServiceClient 추가
   - RestTemplateConfig 추가
   - InternalUserController 추가 (User Service)
   - CommentService에서 User Service 연동
   
4. `feat: add real system metrics API for admin dashboard monitoring`
   - SystemMetrics DTO 추가
   - SystemMetricsService 추가
   - AdminUserController에 `/system/metrics` 엔드포인트 추가
   
5. `fix: accept userId in CreateCommentRequest for comment creation`
6. `fix: accept userId in request for all community features (post, vote, comment, recruitment)`
7. `feat: add popular post feature with daily pinning and fire icon`

### 프론트엔드 커밋 (최신순)
1. `fix: extract post from response in createPost and updatePost`
   - 백엔드 응답 `{post: {...}}` 형태에서 post 객체 추출
   - createPost, updatePost에서 `response.data.post || response.data` 사용
   
2. `fix: display user names correctly in community and profile pages`
   - Layout.tsx: `user?.name || user?.username` 표시
   - ProfilePage.tsx: `profile?.name || profile?.username` 표시
   - CommunityPage.tsx: `post.userName` 표시
   - CommunityDetailPage.tsx: `post.userName`, `comment.userName` 표시
   - Comment 인터페이스에 `userName` 필드 추가
   
3. `feat: add real-time system monitoring to admin dashboard`
   - 실시간 시스템 메트릭 조회 API 연동
   - 5초마다 자동 새로고침
   - 애니메이션 효과 추가 (값 변경 시 부드러운 전환)
   - 펄스 애니메이션 추가
   
4. `fix: include userId in comment creation request`
5. `fix: pass userId to all community API calls (post, vote, comment, recruitment) and add debug logs for map`
6. `feat: add popular post indicator with fire icon and animation`

---

## 🔄 향후 작업 예정

### 인증 시스템 완성
- Gateway Service에서 JWT 토큰 검증 후 userId를 헤더에 추가
- Community Service에서 `@RequestAttribute`로 userId 자동 주입
- 임시로 추가한 요청 본문/쿼리 파라미터의 userId 제거

### 데이터베이스 마이그레이션
- Community Service의 `posts` 테이블에 `is_pinned`, `pinned_until` 컬럼 추가
- 기존 데이터의 기본값 설정 (is_pinned = false, pinned_until = null)

---

## ✅ 테스트 체크리스트

### 커뮤니티 기능
- [x] 게시글 작성 (userId 전달)
- [x] 게시글 투표 (좋아요/싫어요)
- [x] 댓글 작성
- [x] 댓글 투표
- [x] 모집 참여/취소
- [x] 게시글 작성 후 상세 페이지 이동
- [x] 사용자 이름 표시 (게시글/댓글)

### 인기 게시글
- [ ] 매일 자정 스케줄러 실행 확인
- [ ] 추천 10개 이상 게시글 선정 확인
- [ ] 24시간 후 자동 고정 해제 확인
- [x] 목록에서 인기 아이콘 표시 확인
- [ ] 인기 게시글 최상단 정렬 확인

### 관리자 페이지
- [x] 실시간 시스템 메트릭 조회
- [x] 5초마다 자동 새로고침
- [x] 애니메이션 효과
- [x] 사용자 통계 조회
- [x] 커뮤니티 통계 조회

### 마이크로서비스 연동
- [x] User Service → Community Service (사용자 이름 조회)
- [x] 404 에러 처리 (사용자 없을 때 fallback)
- [x] context-path 올바른 처리

---

## 📝 참고사항

### 스케줄러 실행 시간
- **인기 게시글 선정**: 매일 00:00:00 (자정)
- **만료된 고정 해제**: 매 시간 정각

### 인기 게시글 선정 기준
- 지난 24시간 동안 작성된 게시글 중
- 좋아요(likeCount)가 가장 많은 게시글
- 최소 10개 이상의 좋아요 필요
- 선정된 게시글은 24시간 동안 고정

### 임시 인증 방식
- 프론트엔드에서 로그인한 사용자의 ID를 요청에 포함
- 백엔드에서 `@RequestAttribute` 우선, 없으면 요청 본문/쿼리 파라미터 사용
- 실제 서비스에서는 JWT 토큰 검증 후 Gateway에서 userId 주입 필요

