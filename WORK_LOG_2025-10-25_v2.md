# 작업 일지 - 2025년 10월 25일 (v2)

## 📋 작업 개요
커뮤니티 서비스의 인증 시스템 임시 구현 및 인기 게시글 기능 추가

---

## 🔧 User Service

### 수정 사항 없음
- JWT 토큰 발급 기능은 이전에 이미 구현 완료
- 로그인/회원가입 시 JWT 토큰 정상 발급 중

---

## 💬 Community Service

### 1. 임시 인증 시스템 구현 (userId 전달)

#### 문제점
- 프론트엔드에서 API 호출 시 `@RequestAttribute("userId")`가 없어 500 에러 발생
- 게이트웨이/인증 필터가 완전히 구현되지 않아 userId가 전달되지 않음

#### 해결 방법
모든 컨트롤러에서 `@RequestAttribute`를 선택사항으로 변경하고, 임시로 요청 본문/쿼리 파라미터에서 userId를 받도록 수정

#### 수정된 파일

**1) CreatePostRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**2) PostController.java**
```java
@PostMapping
public ResponseEntity<PostResponse> createPost(
        @Valid @RequestBody CreatePostRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    // 임시: 인증 시스템 구현 전까지 요청 본문에서 userId 사용
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    PostDto post = postService.createPost(request, userId);
    return ResponseEntity.status(HttpStatus.CREATED)
        .body(PostResponse.builder().post(post).build());
}
```

**3) CreateCommentRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**4) CommentController.java**
```java
@PostMapping("/posts/{postId}/comments")
public ResponseEntity<CommentDto> createComment(
        @PathVariable Long postId,
        @Valid @RequestBody CreateCommentRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    CommentDto comment = commentService.createComment(postId, request, userId);
    return ResponseEntity.status(HttpStatus.CREATED).body(comment);
}
```

**5) VoteRequest.java**
```java
// 임시: 인증 시스템 구현 전까지 요청 본문에서 받음
private Long userId;
```

**6) VoteController.java**
```java
// 게시글 투표
@PostMapping("/posts/{postId}/vote")
public ResponseEntity<VoteResponse> votePost(
        @PathVariable Long postId,
        @Valid @RequestBody VoteRequest request,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute
) {
    Long userId = userIdFromAttribute != null ? userIdFromAttribute : request.getUserId();
    if (userId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    VoteResponse response = voteService.votePost(postId, request, userId);
    return ResponseEntity.ok(response);
}

// 게시글 투표 취소
@DeleteMapping("/posts/{postId}/vote")
public ResponseEntity<VoteResponse> cancelPostVote(
        @PathVariable Long postId,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute,
        @RequestParam(required = false) Long userId
) {
    Long finalUserId = userIdFromAttribute != null ? userIdFromAttribute : userId;
    if (finalUserId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    VoteResponse response = voteService.cancelPostVote(postId, finalUserId);
    return ResponseEntity.ok(response);
}

// 댓글 투표도 동일한 패턴으로 수정
```

**7) RecruitmentController.java**
```java
@PostMapping("/{postId}/participate")
public ResponseEntity<ParticipateResponse> toggleParticipation(
        @PathVariable Long postId,
        @RequestAttribute(value = "userId", required = false) Long userIdFromAttribute,
        @RequestParam(required = false) Long userId
) {
    Long finalUserId = userIdFromAttribute != null ? userIdFromAttribute : userId;
    if (finalUserId == null) {
        throw new IllegalArgumentException("userId는 필수입니다.");
    }
    ParticipateResponse response = recruitmentService.toggleParticipation(postId, finalUserId);
    return ResponseEntity.ok(response);
}
```

---

### 2. 인기 게시글 기능 추가

#### 기능 설명
- 매일 자정에 지난 24시간 동안 가장 많은 추천을 받은 게시글을 선정
- 선정된 게시글은 24시간 동안 목록 최상단에 고정
- 최소 10개 이상의 추천을 받아야 인기 게시글로 선정

#### 수정/추가된 파일

**1) Post.java (엔티티)**
```java
// 인기 게시글 (상단 고정)
@Column(name = "is_pinned")
@Builder.Default
private Boolean isPinned = false;

@Column(name = "pinned_until")
private LocalDateTime pinnedUntil;

// 비즈니스 메서드
public void pin(LocalDateTime until) {
    this.isPinned = true;
    this.pinnedUntil = until;
}

public void unpin() {
    this.isPinned = false;
    this.pinnedUntil = null;
}

public boolean isPinnedAndValid() {
    return this.isPinned && 
           this.pinnedUntil != null && 
           LocalDateTime.now().isBefore(this.pinnedUntil);
}
```

**2) PostDto.java**
```java
// 인기 게시글
private Boolean isPinned;
private LocalDateTime pinnedUntil;
```

**3) PostService.java**
```java
// convertToDto 메서드에 추가
.isPinned(post.getIsPinned())
.pinnedUntil(post.getPinnedUntil())
```

**4) PostRepository.java**
```java
// 특정 기간 이후 가장 많은 추천을 받은 게시글 조회
@Query("SELECT p FROM Post p WHERE p.isDeleted = false " +
       "AND p.createdAt >= :since " +
       "ORDER BY p.likeCount DESC, p.viewCount DESC")
List<Post> findTopByLikeCountSince(@Param("since") LocalDateTime since, int limit);

// 고정 기간이 만료된 게시글 조회
List<Post> findByIsPinnedTrueAndPinnedUntilBefore(LocalDateTime now);

// 복합 검색 쿼리 수정 - 인기 게시글 우선 정렬
@Query("SELECT p FROM Post p WHERE p.isDeleted = false " +
       "AND (:category IS NULL OR p.category = :category) " +
       "AND (:regionSi IS NULL OR p.regionSi = :regionSi) " +
       "AND (:regionGu IS NULL OR p.regionGu = :regionGu) " +
       "AND (:regionDong IS NULL OR p.regionDong = :regionDong) " +
       "AND (:isRecruitment IS NULL OR p.isRecruitment = :isRecruitment) " +
       "ORDER BY " +
       "CASE WHEN p.isPinned = true AND p.pinnedUntil > CURRENT_TIMESTAMP THEN 0 ELSE 1 END, " +
       "p.createdAt DESC")
Page<Post> findByFilters(...);
```

**5) PopularPostScheduler.java (신규 파일)**
```java
@Component
public class PopularPostScheduler {
    
    /**
     * 매일 자정에 인기 게시글 선정 및 고정
     */
    @Scheduled(cron = "0 0 0 * * *")
    @Transactional
    public void updatePopularPost() {
        // 기존 고정 게시글 해제
        unpinExpiredPosts();
        
        // 지난 24시간 동안 가장 많은 추천을 받은 게시글 찾기
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        List<Post> topPosts = postRepository.findTopByLikeCountSince(yesterday, 1);
        
        if (!topPosts.isEmpty()) {
            Post topPost = topPosts.get(0);
            
            // 최소 추천 수 조건 (10개 이상)
            if (topPost.getLikeCount() >= 10) {
                // 24시간 동안 고정
                LocalDateTime pinnedUntil = LocalDateTime.now().plusDays(1);
                topPost.pin(pinnedUntil);
                postRepository.save(topPost);
                
                log.info("인기 게시글 선정 완료: postId={}, likeCount={}", 
                    topPost.getId(), topPost.getLikeCount());
            }
        }
    }
    
    /**
     * 매 시간마다 만료된 고정 게시글 해제
     */
    @Scheduled(cron = "0 0 * * * *")
    @Transactional
    public void unpinExpiredPosts() {
        LocalDateTime now = LocalDateTime.now();
        List<Post> expiredPosts = postRepository.findByIsPinnedTrueAndPinnedUntilBefore(now);
        
        for (Post post : expiredPosts) {
            post.unpin();
            postRepository.save(post);
            log.info("고정 해제: postId={}", post.getId());
        }
    }
}
```

---

## 🎨 Frontend

### 1. 커뮤니티 API 호출 시 userId 전달

#### 수정된 파일

**1) communityService.ts**
```typescript
// CreatePostRequest 인터페이스
export interface CreatePostRequest {
  // ... 기존 필드들
  userId?: number;  // 임시: 인증 시스템 구현 전까지 필요
}

// CreateCommentRequest 인터페이스
export interface CreateCommentRequest {
  content: string;
  parentCommentId?: number;
  userId?: number;  // 임시: 인증 시스템 구현 전까지 필요
}

// 투표 함수들
export const votePost = async (postId: number, voteType: 'LIKE' | 'DISLIKE', userId?: number): Promise<void> => {
  await api.post(`/api/community/posts/${postId}/vote`, { voteType, userId });
};

export const unvotePost = async (postId: number, userId?: number): Promise<void> => {
  await api.delete(`/api/community/posts/${postId}/vote${userId ? `?userId=${userId}` : ''}`);
};

export const voteComment = async (commentId: number, voteType: 'LIKE' | 'DISLIKE', userId?: number): Promise<void> => {
  await api.post(`/api/community/comments/${commentId}/vote`, { voteType, userId });
};

export const unvoteComment = async (commentId: number, userId?: number): Promise<void> => {
  await api.delete(`/api/community/comments/${commentId}/vote${userId ? `?userId=${userId}` : ''}`);
};

// 모집 참여
export const toggleParticipation = async (postId: number, userId?: number): Promise<{ participated: boolean; currentCount: number }> => {
  const response = await api.post(`/api/community/posts/${postId}/participate${userId ? `?userId=${userId}` : ''}`);
  return response.data;
};

// Post 인터페이스에 인기 게시글 필드 추가
export interface Post {
  // ... 기존 필드들
  isPinned?: boolean;  // 인기 게시글 여부
  pinnedUntil?: string;  // 고정 만료 시간
}
```

**2) CommunityWritePage.tsx**
```typescript
import { useAppSelector } from '../store/hooks';

const CommunityWritePage: React.FC = () => {
  const { user } = useAppSelector((state) => state.auth);
  
  const handleSubmit = async () => {
    // ... 기존 코드
    
    // userId 추가 (임시: 인증 시스템 구현 전까지)
    if (user?.id) {
      request.userId = parseInt(user.id);
    }
    
    const post = await createPost(request);
    navigate(`/community/${post.id}`);
  };
};
```

**3) CommunityDetailPage.tsx**
```typescript
// 투표 처리
const handleVote = async (voteType: 'LIKE' | 'DISLIKE') => {
  if (!id || !user?.id) return;
  const userId = parseInt(user.id);
  
  try {
    if (myVote === voteType) {
      await unvotePost(parseInt(id), userId);
    } else {
      await votePost(parseInt(id), voteType, userId);
    }
    // ... 상태 업데이트
  } catch (err: any) {
    alert(err.response?.data?.message || '추천/비추천에 실패했습니다.');
  }
};

// 모집 참여 처리
const handleParticipate = async () => {
  if (!id || !user?.id) return;
  const userId = parseInt(user.id);
  
  try {
    const result = await toggleParticipation(parseInt(id), userId);
    setParticipated(result.participated);
    // ... 상태 업데이트
  } catch (err: any) {
    alert(err.response?.data?.message || '참여 처리에 실패했습니다.');
  }
};

// 댓글 작성 처리
const handleSubmitComment = async () => {
  await createComment(parseInt(id), {
    content: newComment,
    parentCommentId: replyTo || undefined,
    userId: user?.id ? parseInt(user.id) : undefined,
  });
};
```

---

### 2. 인기 게시글 시각적 표시

**CommunityPage.tsx**
```typescript
import { Whatshot } from '@mui/icons-material';

// 게시글 카드에 인기 아이콘 추가
<Box sx={{ display: 'flex', gap: 1, mb: 1, flexWrap: 'wrap', alignItems: 'center' }}>
  {post.isPinned && post.pinnedUntil && new Date(post.pinnedUntil) > new Date() && (
    <Chip
      label="인기"
      size="small"
      color="error"
      icon={<Whatshot />}
      sx={{
        fontWeight: 'bold',
        animation: 'pulse 2s ease-in-out infinite',
        '@keyframes pulse': {
          '0%, 100%': { opacity: 1 },
          '50%': { opacity: 0.7 },
        },
      }}
    />
  )}
  {/* 기존 카테고리, 지역 등의 칩들 */}
</Box>
```

---

### 3. 지도 디버깅 로그 추가

**HomePage.tsx**
```typescript
// 선호 지역 데이터 로딩 시 로그
const fetchPreferredRegions = async () => {
  const data = await getMyPreferredRegions();
  console.log('선호 지역 데이터:', data);
  console.log('1순위 지역:', firstRegion);
  console.log('1순위 지역 좌표:', coordinate);
};

// 지도에서 보기 버튼 클릭 시 로그
<Button onClick={() => {
  console.log('지도에서 보기 클릭:', region);
  const coordinate = getCoordinatesByDistrict(region.district);
  console.log('찾은 좌표:', coordinate);
  if (coordinate) {
    console.log('지도 중심 변경:', coordinate.latitude, coordinate.longitude);
    setMapCenter({ latitude: coordinate.latitude, longitude: coordinate.longitude });
  } else {
    console.error('좌표를 찾을 수 없습니다. district:', region.district);
  }
}}>
  지도에서 보기
</Button>
```

---

## 📊 배포 현황

### 백엔드 커밋
1. `fix: accept userId in CreateCommentRequest for comment creation`
2. `fix: accept userId in request for all community features (post, vote, comment, recruitment)`
3. `feat: add popular post feature with daily pinning and fire icon`

### 프론트엔드 커밋
1. `fix: include userId in comment creation request`
2. `fix: pass userId to all community API calls (post, vote, comment, recruitment) and add debug logs for map`
3. `feat: add popular post indicator with fire icon and animation`

---

## 🔄 향후 작업 예정

### 인증 시스템 완성
- Gateway Service에서 JWT 토큰 검증 후 userId를 헤더에 추가
- Community Service에서 `@RequestAttribute`로 userId 자동 주입
- 임시로 추가한 요청 본문/쿼리 파라미터의 userId 제거

### 데이터베이스 마이그레이션
- Community Service의 `posts` 테이블에 `is_pinned`, `pinned_until` 컬럼 추가
- 기존 데이터의 기본값 설정 (is_pinned = false, pinned_until = null)

---

## ✅ 테스트 체크리스트

### 커뮤니티 기능
- [x] 게시글 작성 (userId 전달)
- [x] 게시글 투표 (좋아요/싫어요)
- [x] 댓글 작성
- [x] 댓글 투표
- [x] 모집 참여/취소

### 인기 게시글
- [ ] 매일 자정 스케줄러 실행 확인
- [ ] 추천 10개 이상 게시글 선정 확인
- [ ] 24시간 후 자동 고정 해제 확인
- [ ] 목록에서 인기 아이콘 표시 확인
- [ ] 인기 게시글 최상단 정렬 확인

---

## 📝 참고사항

### 스케줄러 실행 시간
- **인기 게시글 선정**: 매일 00:00:00 (자정)
- **만료된 고정 해제**: 매 시간 정각

### 인기 게시글 선정 기준
- 지난 24시간 동안 작성된 게시글 중
- 좋아요(likeCount)가 가장 많은 게시글
- 최소 10개 이상의 좋아요 필요
- 선정된 게시글은 24시간 동안 고정

### 임시 인증 방식
- 프론트엔드에서 로그인한 사용자의 ID를 요청에 포함
- 백엔드에서 `@RequestAttribute` 우선, 없으면 요청 본문/쿼리 파라미터 사용
- 실제 서비스에서는 JWT 토큰 검증 후 Gateway에서 userId 주입 필요

